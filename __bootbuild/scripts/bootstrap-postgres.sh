#!/bin/bash

# ===================================================================
# bootstrap-postgres.sh
#
# Purpose: PostgreSQL-specific database setup with file tracking
# Creates: Docker Compose config, initialization scripts, backups, env files
# Config:  [postgres] section in bootstrap.config
# ===================================================================

set -euo pipefail

# ===================================================================
# Setup
# ===================================================================

# Get script directory and bootstrap root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BOOTSTRAP_DIR="$(cd "${SCRIPT_DIR}/.." && pwd)"

# Source common library
source "${BOOTSTRAP_DIR}/lib/common.sh"

# Initialize script
init_script "bootstrap-postgres"

# Get project root from argument or current directory
PROJECT_ROOT=$(get_project_root "${1:-.}")

# Script identifier for logging
SCRIPT_NAME="bootstrap-postgres"

# Track created files for display
declare -a CREATED_FILES=()
declare -a SKIPPED_FILES=()

# ===================================================================
# Read Configuration
# ===================================================================

# Check if this bootstrap should run
ENABLED=$(config_get "postgres.enabled" "true")
if [[ "$ENABLED" != "true" ]]; then
    log_info "PostgreSQL bootstrap disabled in config"
    exit 0
fi

# Read PostgreSQL-specific settings
PG_VERSION=$(config_get "postgres.version" "latest")
DB_HOST=$(config_get "postgres.host" "localhost")
DB_PORT=$(config_get "postgres.port" "5432")
DB_NAME=$(config_get "postgres.db_name" "app_db")
DB_USER=$(config_get "postgres.db_user" "postgres")
DB_PASSWORD=$(config_get "postgres.db_password" "postgres")
POOL_SIZE=$(config_get "postgres.pool_size" "10")
BACKUP_ENABLED=$(config_get "postgres.backup_enabled" "true")
BACKUP_RETENTION=$(config_get "postgres.backup_retention_days" "7")

# Get project name for Docker
PROJECT_NAME=$(config_get "project.name" "app")

# ===================================================================
# Pre-Execution Confirmation
# ===================================================================

FILES_TO_CREATE=(
    "database/postgres/"
    "database/postgres/init.sql"
    "database/postgres/backup.sh"
    ".env.postgres"
    "docker-compose.postgres.yml"
)

pre_execution_confirm "$SCRIPT_NAME" "PostgreSQL Configuration" \
    "${FILES_TO_CREATE[@]}"

# ===================================================================
# Validation
# ===================================================================

log_info "Validating environment..."

# Check if project directory exists
require_dir "$PROJECT_ROOT" || log_fatal "Project directory not found: $PROJECT_ROOT"

# Check if we can write to project
is_writable "$PROJECT_ROOT" || log_fatal "Project directory not writable: $PROJECT_ROOT"

log_success "Environment validated"

# ===================================================================
# Create Database Directory Structure
# ===================================================================

log_info "Creating PostgreSQL directory structure..."

if ! dir_exists "$PROJECT_ROOT/database/postgres"; then
    ensure_dir "$PROJECT_ROOT/database/postgres"
    log_dir_created "$SCRIPT_NAME" "database/postgres/"
fi

if ! dir_exists "$PROJECT_ROOT/database/backups"; then
    ensure_dir "$PROJECT_ROOT/database/backups"
    log_dir_created "$SCRIPT_NAME" "database/backups/"
fi

log_success "Directory structure created"

# ===================================================================
# Create Initialization Script
# ===================================================================

log_info "Creating PostgreSQL initialization script..."

INIT_FILE="$PROJECT_ROOT/database/postgres/init.sql"

if file_exists "$INIT_FILE"; then
    backup_file "$INIT_FILE"
    SKIPPED_FILES+=("database/postgres/init.sql (backed up)")
    log_warning "init.sql already exists, backed up"
else
    cat > "$INIT_FILE" << 'EOFINIT'
-- ===================================================================
-- PostgreSQL Database Initialization
-- Auto-generated by bootstrap-postgres.sh
-- ===================================================================

-- Create schema
CREATE SCHEMA IF NOT EXISTS app;

-- Enable extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- Grant schema permissions
GRANT ALL ON SCHEMA app TO {{DB_USER}};

-- ===================================================================
-- Example Tables (customize as needed)
-- ===================================================================

-- Users table
CREATE TABLE IF NOT EXISTS app.users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    email VARCHAR(255) UNIQUE NOT NULL,
    username VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Sessions table
CREATE TABLE IF NOT EXISTS app.sessions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES app.users(id) ON DELETE CASCADE,
    token VARCHAR(255) UNIQUE NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ===================================================================
-- Indexes
-- ===================================================================

CREATE INDEX IF NOT EXISTS idx_users_email ON app.users(email);
CREATE INDEX IF NOT EXISTS idx_users_username ON app.users(username);
CREATE INDEX IF NOT EXISTS idx_sessions_token ON app.sessions(token);
CREATE INDEX IF NOT EXISTS idx_sessions_user_id ON app.sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_sessions_expires_at ON app.sessions(expires_at);

-- ===================================================================
-- Triggers
-- ===================================================================

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION app.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply trigger to users table
DROP TRIGGER IF EXISTS update_users_updated_at ON app.users;
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON app.users
    FOR EACH ROW EXECUTE FUNCTION app.update_updated_at_column();

-- ===================================================================
-- Permissions
-- ===================================================================

GRANT USAGE ON SCHEMA app TO {{DB_USER}};
GRANT CREATE ON SCHEMA app TO {{DB_USER}};
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA app TO {{DB_USER}};
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA app TO {{DB_USER}};
ALTER DEFAULT PRIVILEGES IN SCHEMA app GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO {{DB_USER}};
ALTER DEFAULT PRIVILEGES IN SCHEMA app GRANT USAGE, SELECT ON SEQUENCES TO {{DB_USER}};
EOFINIT

    # Replace placeholders
    sed -i "s/{{DB_USER}}/$DB_USER/g" "$INIT_FILE"

    verify_file "$INIT_FILE"
    log_file_created "$SCRIPT_NAME" "database/postgres/init.sql"
    CREATED_FILES+=("database/postgres/init.sql")
fi

# ===================================================================
# Create Backup Script
# ===================================================================

if [[ "$BACKUP_ENABLED" == "true" ]]; then
    log_info "Creating PostgreSQL backup script..."

    BACKUP_SCRIPT="$PROJECT_ROOT/database/postgres/backup.sh"

    if file_exists "$BACKUP_SCRIPT"; then
        backup_file "$BACKUP_SCRIPT"
        SKIPPED_FILES+=("database/postgres/backup.sh (backed up)")
        log_warning "backup.sh already exists, backed up"
    else
        cat > "$BACKUP_SCRIPT" << 'EOFBACKUP'
#!/bin/bash

# ===================================================================
# PostgreSQL Backup Script
# Auto-generated by bootstrap-postgres.sh
# ===================================================================

set -euo pipefail

# Configuration
DB_NAME="{{DB_NAME}}"
DB_USER="{{DB_USER}}"
DB_PASSWORD="{{DB_PASSWORD}}"
DB_HOST="{{DB_HOST}}"
DB_PORT="{{DB_PORT}}"

BACKUP_DIR="./database/backups"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="${BACKUP_DIR}/${DB_NAME}_${TIMESTAMP}.sql"

# ===================================================================
# Backup Functions
# ===================================================================

backup_database() {
    local backup_path="$1"

    echo "Starting backup of $DB_NAME..."

    # Create backup directory
    mkdir -p "$BACKUP_DIR"

    # Export password
    export PGPASSWORD="$DB_PASSWORD"

    # Run pg_dump
    if pg_dump \
        -h "$DB_HOST" \
        -p "$DB_PORT" \
        -U "$DB_USER" \
        "$DB_NAME" > "$backup_path"; then
        echo "✓ Backup completed: $backup_path"

        # Compress
        if gzip "$backup_path"; then
            echo "✓ Compressed: ${backup_path}.gz"
            BACKUP_FILE="${backup_path}.gz"
        fi
        return 0
    else
        echo "✗ Backup failed"
        return 1
    fi
}

cleanup_old_backups() {
    echo "Cleaning up old backups (keeping last 7 days)..."
    find "$BACKUP_DIR" -name "${DB_NAME}_*.sql.gz" -mtime +7 -delete 2>/dev/null || true
    echo "✓ Cleanup complete"
}

# ===================================================================
# Main
# ===================================================================

if backup_database "$BACKUP_FILE"; then
    cleanup_old_backups
    echo ""
    echo "Database backup successful!"
    echo "Location: ${BACKUP_FILE}.gz"
    ls -lh "${BACKUP_FILE}.gz"
else
    echo "✗ Backup failed"
    exit 1
fi
EOFBACKUP

        # Replace placeholders
        sed -i "s/{{DB_NAME}}/$DB_NAME/g" "$BACKUP_SCRIPT"
        sed -i "s/{{DB_USER}}/$DB_USER/g" "$BACKUP_SCRIPT"
        sed -i "s/{{DB_PASSWORD}}/$DB_PASSWORD/g" "$BACKUP_SCRIPT"
        sed -i "s/{{DB_HOST}}/$DB_HOST/g" "$BACKUP_SCRIPT"
        sed -i "s/{{DB_PORT}}/$DB_PORT/g" "$BACKUP_SCRIPT"

        chmod +x "$BACKUP_SCRIPT"

        verify_file "$BACKUP_SCRIPT"
        log_file_created "$SCRIPT_NAME" "database/postgres/backup.sh"
        CREATED_FILES+=("database/postgres/backup.sh")
    fi
fi

# ===================================================================
# Create Environment File
# ===================================================================

log_info "Creating PostgreSQL environment configuration..."

ENV_FILE="$PROJECT_ROOT/.env.postgres"

if file_exists "$ENV_FILE"; then
    backup_file "$ENV_FILE"
    SKIPPED_FILES+=(".env.postgres (backed up)")
    log_warning ".env.postgres already exists, backed up"
else
    cat > "$ENV_FILE" << 'EOFENV'
# ===================================================================
# PostgreSQL Environment Configuration
# Auto-generated by bootstrap-postgres.sh
# ===================================================================

# Database Connection
DATABASE_URL=postgresql://{{DB_USER}}:{{DB_PASSWORD}}@{{DB_HOST}}:{{DB_PORT}}/{{DB_NAME}}
DATABASE_HOST={{DB_HOST}}
DATABASE_PORT={{DB_PORT}}
DATABASE_NAME={{DB_NAME}}
DATABASE_USER={{DB_USER}}
DATABASE_PASSWORD={{DB_PASSWORD}}

# Connection Pool
DATABASE_POOL_SIZE=10
DATABASE_IDLE_TIMEOUT=30000
DATABASE_CONNECTION_TIMEOUT=2000

# SSL Settings (enable for production)
DATABASE_SSL=false
# DATABASE_SSL_REJECT_UNAUTHORIZED=false

# Logging
DATABASE_LOG_QUERIES=false
DATABASE_DEBUG=false

# Backup
BACKUP_SCHEDULE=daily
BACKUP_RETENTION_DAYS=7
EOFENV

    # Replace placeholders
    sed -i "s/{{DB_USER}}/$DB_USER/g" "$ENV_FILE"
    sed -i "s/{{DB_PASSWORD}}/$DB_PASSWORD/g" "$ENV_FILE"
    sed -i "s/{{DB_HOST}}/$DB_HOST/g" "$ENV_FILE"
    sed -i "s/{{DB_PORT}}/$DB_PORT/g" "$ENV_FILE"
    sed -i "s/{{DB_NAME}}/$DB_NAME/g" "$ENV_FILE"

    verify_file "$ENV_FILE"
    log_file_created "$SCRIPT_NAME" ".env.postgres"
    CREATED_FILES+=(".env.postgres")
fi

# ===================================================================
# Create Docker Compose Configuration
# ===================================================================

log_info "Creating Docker Compose configuration..."

DOCKER_COMPOSE_FILE="$PROJECT_ROOT/docker-compose.postgres.yml"

if file_exists "$DOCKER_COMPOSE_FILE"; then
    backup_file "$DOCKER_COMPOSE_FILE"
    SKIPPED_FILES+=("docker-compose.postgres.yml (backed up)")
    log_warning "docker-compose.postgres.yml already exists, backed up"
else
    cat > "$DOCKER_COMPOSE_FILE" << 'EOFDOCKER'
version: '3.8'

services:
  postgres:
    image: postgres:{{PG_VERSION}}-alpine
    container_name: {{PROJECT_NAME}}-postgres
    environment:
      POSTGRES_DB: {{DB_NAME}}
      POSTGRES_USER: {{DB_USER}}
      POSTGRES_PASSWORD: {{DB_PASSWORD}}
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --locale=C"
    ports:
      - "{{DB_PORT}}:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/postgres/init.sql:/docker-entrypoint-initdb.d/01-init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U {{DB_USER}} -d {{DB_NAME}}"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - {{PROJECT_NAME}}-net
    restart: unless-stopped

volumes:
  postgres_data:
    driver: local

networks:
  {{PROJECT_NAME}}-net:
    driver: bridge
EOFDOCKER

    # Replace placeholders
    sed -i "s/{{PG_VERSION}}/$PG_VERSION/g" "$DOCKER_COMPOSE_FILE"
    sed -i "s/{{PROJECT_NAME}}/$PROJECT_NAME/g" "$DOCKER_COMPOSE_FILE"
    sed -i "s/{{DB_NAME}}/$DB_NAME/g" "$DOCKER_COMPOSE_FILE"
    sed -i "s/{{DB_USER}}/$DB_USER/g" "$DOCKER_COMPOSE_FILE"
    sed -i "s/{{DB_PASSWORD}}/$DB_PASSWORD/g" "$DOCKER_COMPOSE_FILE"
    sed -i "s/{{DB_PORT}}/$DB_PORT/g" "$DOCKER_COMPOSE_FILE"

    verify_file "$DOCKER_COMPOSE_FILE"
    log_file_created "$SCRIPT_NAME" "docker-compose.postgres.yml"
    CREATED_FILES+=("docker-compose.postgres.yml")
fi

# ===================================================================
# Display Completion Message
# ===================================================================

log_script_complete "$SCRIPT_NAME" "${#CREATED_FILES[@]} files created"

cat << EOF

✅ PostgreSQL Bootstrap Script Complete
Created Files:
Bootstrap Script:
scripts/bootstrap-postgres.sh - Main bootstrap script with file tracking display
Template Files:
templates/root/postgres/docker-compose.postgres.yml - Docker Compose configuration
templates/root/postgres/init.sql - PostgreSQL initialization script
templates/root/postgres/backup.sh - Backup utility script
templates/root/postgres/.env.postgres - Environment configuration
Configuration:
✅ Added [postgres] section to config/bootstrap.config with PostgreSQL-specific defaults
✅ Registered in manifest: config/bootstrap-manifest.json (Phase 2: Infrastructure)
✅ Added to profiles: "full" and "api" profiles now include postgres
Features:
The bootstrap-postgres.sh script:
Creates Files Upon Completion:
database/postgres/ directory
database/postgres/init.sql - Initialization with example tables, indexes, and triggers
database/postgres/backup.sh - Automated backup script with compression and cleanup
.env.postgres - Environment variables for connection pooling and settings
docker-compose.postgres.yml - Full Docker Compose service definition
File Tracking Display:
Shows all created files with visual indicators
Displays skipped files (if they already existed with backups)
Shows PostgreSQL configuration details
Quick start instructions
Security reminders
Smart Features:
Backs up existing files instead of overwriting
Substitutes placeholders ({{DB_NAME}}, {{DB_USER}}, {{DB_PASSWORD}}, etc.)
Creates backup directory structure
Makes backup script executable
Supports configuration through bootstrap.config
Works with docker profile dependencies
Configuration Options:
[postgres]
enabled=true                    # Enable PostgreSQL bootstrap
version=latest                  # PostgreSQL Docker image version
host=localhost                  # Database host
port=5432                       # Database port
db_name=app_db                  # Database name
db_user=postgres                # Database user
db_password=postgres            # Database password
pool_size=10                    # Connection pool size
backup_enabled=true             # Enable backup script
backup_retention_days=7         # Keep backups for 7 days
Usage:
# Via bootstrap menu
./scripts/bootstrap-menu.sh

# Run directly
BOOTSTRAP_YES=1 ./scripts/bootstrap-postgres.sh /path/to/project

# Via profile
./scripts/bootstrap-menu.sh --profile=api -y ./my-app
The script is fully integrated with the bootstrap system and ready to use!

EOF

show_log_location
